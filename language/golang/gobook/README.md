# Gobook

> links
> - [gobook sourcecode](www.qtrac.eu/gobook.html)
> - [godashboard](godashboard.appspot.com/project)

---

## Зачем изучать язык Go?

> 10 ноября 2009 года были опубликованы исходные тексты реализации языка Go под либеральной открытой лицензией. 

Благодаря высокой скорости компиляции программ на языке Go появляется возможность использовать этот язык в областях, где обычно применяются языки сценариев (см. врезку «Сценарии на языке Go» ниже). Кроме того, язык Go можно использовать для создания веб-приложений с применением Google App Engine.[p.13]

- [x] строгая статическая типизация.
  - считается важным условием для разработки крупных программ.
- [x] Система типов: компилятор определяет тип автоматически, избавляя от необходимости явно указывать его.
- [x]  Для управления памятью в Go имеется механизм сборки мусора, что избавляет от необходимости использовать «интеллектуальные» указатели или освобождать память вручную.[p.14]
- [x] `параллелизм:` в языке Go реализован в форме механизма взаимодействующих последовательных
процессов (Communicating Sequential Processes, CSP), 

> основанного на идеях специалиста в области теории 
> вычислительных машин и систем Чарльза Энтони Ричарда Хоара 
> (C. A. R. Hoare) , благодаря которому во многих 
> многопоточных программах на языке Go вообще **отпадает** 
> **необходимость блокировать доступ к ресурсам**.

- [x] `Go-подпрограммы` (goroutines) – очень легковесные процессы, которых можно создать великое множество.

> Go – практичный язык, где **во главу угла поставлены** _эффективность_ **программ и** _удобство_ **программиста**. 

- [x] В Go имеются также два встроенных фундаментальных типа коллекций: 
  - **`срезы`** (slices) (фактически ссылки на массивы переменной длины);
  - **`отображения`** (maps) (словари, или хеши пар ключ/значение);
  > Коллекции этих типов высокооптимизированы и с успехом могут использоваться для решения самых разных задач.
    -  `срезы` и `отображения` в Go сильно напоминают `списки` и `словари` в Python.[p.15]
- [x] **`указатели`** (это действительно компилирующий язык программирования – в нем отсутствует какая-либо виртуальная машина, снижающая производительность), что позволяет с непринужденностью создавать собственные, весьма сложные типы данных, такие как `сбалансированные двоичные деревья`.
- [x] Процедурный ЯП + ООП
- [x] Реализация ООП - проще в использовании и значительно гибче.


---

- 1983 `C++`
- 1995 `Java`

---

